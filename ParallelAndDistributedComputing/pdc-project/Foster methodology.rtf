{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf500
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 One approach to partitioning:\
\
recursively partitioning so that each task consists of calculating one term of the sum in the L/R-update. \
\
After you can agglomerate L on its rows, since you always need the same row (i) to calculate Bij in the update of Lik. Similarly, you can agglomerate the columns in R. \
\
Now there will only be communication of rows/columns between these tasks, although this still might be too big of a overhead (for example, you still have to send the whole matrix R just to calculate the update of one element of the L-matrix - to calculate the Bij\'92s in the sum). \
\
For the moment I haven\'92t found a better solution that avoids all this communication between L and R.}